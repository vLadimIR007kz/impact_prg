<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2GIS Navi API</title>
    <meta name="description" content="Navi API directions example" />
    <style>
        html, body, #container {
            margin: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #reset {
            padding: 4px 10px;
            background: #00a81f;
            border-radius: 4px;
            box-shadow: 0 1px 3px 0 rgba(38, 38, 38, 0.5);
            border: none;
            color: #fff;
            font-size: 13px;
            cursor: pointer;
        }
        #reset:disabled {
            background: #f2f2f2;
            color: #6e6d6d;
            cursor: default;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <script src="https://mapgl.2gis.com/api/js/v1"></script>
    <script src="https://unpkg.com/@2gis/mapgl-directions@^2/dist/directions.js"></script>
    <script>
        const map = new mapgl.Map('container', {
            center: [37.668598, 55.76259],
            zoom: 13,
            key: '297a0b42-6f4d-4f79-aeaa-117e64c166b1',
        });

        const directions = new mapgl.Directions(map, {
            directionsApiKey: '297a0b42-6f4d-4f79-aeaa-117e64c166b1',
        });

        const markers = [];
        let firstPoint;
        let secondPoint;
        let routeCoordinates = [];
        let selecting = 'a';
        const buttonText = ['Choose two points on the map', 'Reset points'];

        const controlsHtml = `<button id="reset" disabled>${buttonText[0]}</button>`;
        new mapgl.Control(map, controlsHtml, {
            position: 'topLeft',
        });
        const resetButton = document.getElementById('reset');

        resetButton.addEventListener('click', function() {
            selecting = 'a';
            firstPoint = undefined;
            secondPoint = undefined;
            routeCoordinates = [];
            directions.clear();
            this.disabled = true;
            this.textContent = buttonText[0];
        });

        map.on('click', (e) => {
            const coords = e.lngLat;

            if (selecting != 'end') {
                markers.push(
                    new mapgl.Marker(map, {
                        coordinates: coords,
                        icon: 'https://docs.2gis.com/img/dotMarker.svg',
                    })
                );
            }

            if (selecting === 'a') {
                firstPoint = coords;
                selecting = 'b';
            } else if (selecting === 'b') {
                secondPoint = coords;
                selecting = 'end';
            }

            if (firstPoint && secondPoint) {
                directions.pedestrianRoute({
                    points: [firstPoint, secondPoint],
                }).then(result => {
                    if (result && result.routes && result.routes.length > 0 && result.routes[0].geometry) {
                        routeCoordinates = result.routes[0].geometry;
                        checkPointsOnRoute();
                    } else {
                        console.error('No route found');
                    }
                }).catch(error => {
                    console.error('Error generating route:', error);
                });
                markers.forEach((m) => m.destroy());
                resetButton.disabled = false;
                resetButton.textContent = buttonText[1];
            }
        });

        fetch('http://localhost:80/impact_prg/2gis/map.geojson')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                data.features.forEach(feature => {
                    const coord = feature.geometry.coordinates;
                    const properties = feature.properties;
                    markers.push(
                        new mapgl.Marker(map, {
                            coordinates: coord,
                            icon: 'https://docs.2gis.com/img/dotMarker.svg',
                        })
                    );
                });
            })
            .catch(error => {
                console.error('Error loading GeoJSON data:', error);
            });

        function checkPointsOnRoute() {
            fetch('http://localhost:80/impact_prg/2gis/map.geojson')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    data.features.forEach(feature => {
                        const point = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]];
                        if (isPointOnRoute(point, routeCoordinates, 0.01)) { // 0.01 is the threshold distance in degrees
                            console.log('Point on route:', feature.properties.name);
                            // Optionally, you can add a marker or perform some action
                        }
                    });
                })
                .catch(error => {
                    console.error('Error checking points on route:', error);
                });
        }

        function isPointOnRoute(point, route, threshold) {
            for (let i = 0; i < route.length - 1; i++) {
                const segmentStart = route[i];
                const segmentEnd = route[i + 1];
                if (distanceToSegment(point, segmentStart, segmentEnd) < threshold) {
                    return true;
                }
            }
            return false;
        }

        function haversineDistance([lat1, lon1], [lat2, lon2]) {
            const R = 6371; // Radius of the Earth in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function distanceToSegment(point, segmentStart, segmentEnd) {
            const [x0, y0] = point;
            const [x1, y1] = segmentStart;
            const [x2, y2] = segmentEnd;
            const A = x0 - x1;
            const B = y0 - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            const param = len_sq !== 0 ? dot / len_sq : -1;
            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            return haversineDistance([x0, y0], [xx, yy]);
        }
    </script>
</body>
</html>
